(window.onbeforeunload = function (e) {
    e.preventDefault(), (e.returnValue = "Really want to quit the game?");
}),
    (document.onkeydown = function (e) {
        if ((e = e || window.event).ctrlKey)
            switch (e.which || e.keyCode) {
                case 83:
                case 87:
                    e.preventDefault(), e.stopPropagation();
            }
    });
var cursor = document.getElementById("cursor");
(cursor.style.left = (0.5 * window.innerWidth - 0.5 * cursor.width).toString() + "px"), (cursor.style.top = (0.5 * window.innerHeight - 0.5 * cursor.height).toString() + "px");
function animate() {
    requestAnimationFrame(animate);
}
requestAnimationFrame(animate), noise.seed(Math.random());
var scene = new THREE.Scene();
(scene.background = new THREE.Color(65535)), (scene.fog = new THREE.Fog(65535, 10, 650));
var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight), document.body.appendChild(renderer.domElement);
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1e3),
    faces = [{ dir: [-5, 0, 0, "left"] }, { dir: [5, 0, 0, "right"] }, { dir: [0, -5, 0, "bottom"] }, { dir: [0, 5, 0, "top"] }, { dir: [0, 0, -5, "back"] }, { dir: [0, 0, 5, "front"] }];
function Block(e, n, r, o, a) {
    (this.x = e), (this.y = n), (this.z = r), (this.placed = o), (this.blockType = a);
}
var chunks = [],
    xoff = 0,
    zoff = 0,
    inc = 0.05,
    amplitude = 30 + 70 * Math.random(),
    renderDistance = 5,
    chunkSize = 10,
    depth = 6,
    minWorldY = -500;
(camera.position.x = ((renderDistance * chunkSize) / 2) * 5), (camera.position.z = ((renderDistance * chunkSize) / 2) * 5), (camera.position.y = 75);
const loader = new THREE.TextureLoader();
loader.load("https://res.cloudinary.com/dpoer5oaq/image/upload/v1630412991/Screen_Shot_2021-08-31_at_8.29.22_AM_y8ycyr.png", function (e) {
    scene.background = e;
}),
    (hemiLight = new THREE.HemisphereLight(255, 65280, 0.6));
for (
    var materialArray = [
            new THREE.MeshBasicMaterial({ map: loader.load("texture/texture.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/texture.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/texture.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/texture.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/texture.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/texture.png") }),
        ],
        blockBox = new THREE.BoxGeometry(5, 5, 5),
        grassTexture = [
            new THREE.MeshBasicMaterial({ map: loader.load("texture/grass/side.jpg") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/grass/side.jpg") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/grass/top.jpg") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/grass/bottom.jpg") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/grass/side.jpg") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/grass/side.jpg") }),
        ],
        dirtTexture = [
            new THREE.MeshBasicMaterial({ map: loader.load("texture/dirt/dirt.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/dirt/dirt.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/dirt/dirt.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/dirt/dirt.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/dirt/dirt.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/dirt/dirt.png") }),
        ],
        woodTexture = [
            new THREE.MeshBasicMaterial({ map: loader.load("texture/wood/wood.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/wood/wood.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/wood/wood.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/wood/wood.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/wood/wood.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/wood/wood.png") }),
        ],
        brickTexture = [
            new THREE.MeshBasicMaterial({ map: loader.load("texture/brick/brick.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/brick/brick.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/brick/brick.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/brick/brick.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/brick/brick.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/brick/brick.png") }),
        ],
        cobblestoneTexture = [
            new THREE.MeshBasicMaterial({ map: loader.load("texture/cobblestone/cobblestone.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/cobblestone/cobblestone.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/cobblestone/cobblestone.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/cobblestone/cobblestone.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/cobblestone/cobblestone.png") }),
            new THREE.MeshBasicMaterial({ map: loader.load("texture/cobblestone/cobblestone.png") }),
        ],
        blocks = [
            { name: "grass", materialArray: grassTexture, mesh: new THREE.InstancedMesh(blockBox, grassTexture, renderDistance * renderDistance * chunkSize * chunkSize * depth), count: 0, range: [0] },
            { name: "dirt", materialArray: dirtTexture, mesh: new THREE.InstancedMesh(blockBox, dirtTexture, renderDistance * renderDistance * chunkSize * chunkSize * depth), count: 0, range: [1, 2] },
            { name: "cobblestone", materialArray: cobblestoneTexture, mesh: new THREE.InstancedMesh(blockBox, cobblestoneTexture, renderDistance * renderDistance * chunkSize * chunkSize * depth), count: 0, range: [5, 6] },
            { name: "wood", materialArray: woodTexture, mesh: new THREE.InstancedMesh(blockBox, woodTexture, renderDistance * renderDistance * chunkSize * chunkSize * depth), count: 0, range: [3] },
            { name: "brick", materialArray: brickTexture, mesh: new THREE.InstancedMesh(blockBox, brickTexture, renderDistance * renderDistance * chunkSize * chunkSize * depth), count: 0, range: [4] },
        ],
        blockTypes = ["grass", "dirt", "cobblestone", "wood", "brick"],
        make_type = "grass",
        i = 0;
    i < renderDistance;
    i++
)
    for (j = 0; j < renderDistance; j++) {
        for (var chunk = [], x = i * chunkSize; x < i * chunkSize + chunkSize; x++)
            for (var z = j * chunkSize; z < j * chunkSize + chunkSize; z++) {
                (xoff = inc * x), (zoff = inc * z);
                for (var v = 5 * Math.round((noise.perlin2(xoff, zoff) * amplitude) / 5), d = 0; d < depth; d++) {
                    if (v - 5 * d < minWorldY) continue;
                    let e = new THREE.Matrix4().makeTranslation(5 * x, v - 5 * d, 5 * z);
                    for (var b = 0; b < blocks.length; b++) blocks[b].range.includes(d) && (blocks[b].mesh.setMatrixAt(blocks[b].count, e), blocks[b].count++, chunk.push(new Block(5 * x, v - 5 * d, 5 * z, !1, blocks[b].name)));
                }
            }
        chunks.push(chunk);
    }
for (i = 0; i < blocks.length; i++) scene.add(blocks[i].mesh);
var keys = [],
    canJump = !0,
    controlOptions = {
        forward: "w",
        up: "ArrowUp",
        backward: "s",
        down: "ArrowDown",
        right: "d",
        rarrow: "ArrowRight",
        left: "a",
        larrow: "ArrowLeft",
        jump: " ",
        placeBlock: "Backspace",
        placeBlockr: "Enter",
        one: "1",
        two: "2",
        three: "3",
        four: "4",
        five: "5",
        fly: "f",
    },
    placedBlocks = [],
    chunkMap = [];
for (x = 0; x < renderDistance; x++) for (z = 0; z < renderDistance; z++) chunkMap.push({ x: x, z: z });
function identifyChunk(e, n) {
    for (var r = e - lowestXBlock(), o = n - lowestZBlock(), a = Math.floor(r / (5 * chunkSize)), t = Math.floor(o / (5 * chunkSize)), c = void 0, s = 0; s < chunkMap.length; s++)
        if (chunkMap[s].x == a && chunkMap[s].z == t) {
            c = s;
            break;
        }
    return c;
}
var start = 0,
    sprint = !1;
document.addEventListener("keydown", function (e) {
    var n;
    "w" == e.key && ((n = new Date().getTime()) - start <= 300 && (sprint = !0), (start = n));
    "ArrowUp" == e.key && ((n = new Date().getTime()) - start <= 300 && (sprint = !0), (start = n));
    if (
        (keys.push(e.key),
        e.key == controlOptions.jump && 1 == canJump && ((ySpeed = -1), (canJump = !1)),
        e.key == controlOptions.fly && (ySpeed = -1),
        e.key == controlOptions.one &&
            ((make_type = "grass"),
            document.getElementById("one").classList.add("opa"),
            document.getElementById("two").classList.remove("opa"),
            document.getElementById("three").classList.remove("opa"),
            document.getElementById("four").classList.remove("opa"),
            document.getElementById("five").classList.remove("opa")),
        e.key == controlOptions.two &&
            ((make_type = "dirt"),
            document.getElementById("one").classList.remove("opa"),
            document.getElementById("two").classList.add("opa"),
            document.getElementById("three").classList.remove("opa"),
            document.getElementById("four").classList.remove("opa"),
            document.getElementById("five").classList.remove("opa")),
        e.key == controlOptions.three &&
            ((make_type = "cobblestone"),
            document.getElementById("one").classList.remove("opa"),
            document.getElementById("two").classList.remove("opa"),
            document.getElementById("three").classList.add("opa"),
            document.getElementById("four").classList.remove("opa"),
            document.getElementById("five").classList.remove("opa")),
        e.key == controlOptions.four &&
            ((make_type = "wood"),
            document.getElementById("one").classList.remove("opa"),
            document.getElementById("two").classList.remove("opa"),
            document.getElementById("three").classList.remove("opa"),
            document.getElementById("four").classList.add("opa"),
            document.getElementById("five").classList.remove("opa")),
        e.key == controlOptions.five &&
            ((make_type = "brick"),
            document.getElementById("one").classList.remove("opa"),
            document.getElementById("two").classList.remove("opa"),
            document.getElementById("three").classList.remove("opa"),
            document.getElementById("four").classList.remove("opa"),
            document.getElementById("five").classList.add("opa")),
        e.key == controlOptions.placeBlockr)
    ) {
        const e = new THREE.Raycaster(),
            n = new THREE.Vector2();
        (n.x = 0), (n.y = 0), e.setFromCamera(n, camera);
        for (var r = !1, o = 1 / 0, a = 0; a < blocks.length; a++) {
            null != (y = e.intersectObject(blocks[a].mesh))[0] && y[0].distance < 40 && y[0].distance < o && ((r = !0), (u = y), (o = y[0].distance));
        }
        if (r) {
            console.log(u[0]);
            var t = u[0].face.materialIndex,
                c = u[0].point,
                s = 0,
                l = 0,
                i = 0;
            const e = 2.5;
            switch (t) {
                case 0:
                    (s = c.x + e), (l = 5 * Math.round(c.y / 5)), (i = 5 * Math.round(c.z / 5));
                    break;
                case 1:
                    (s = c.x - e), (l = 5 * Math.round(c.y / 5)), (i = 5 * Math.round(c.z / 5));
                    break;
                case 2:
                    (s = 5 * Math.round(c.x / 5)), (l = c.y + e), (i = 5 * Math.round(c.z / 5));
                    break;
                case 3:
                    (s = 5 * Math.round(c.x / 5)), (l = c.y - e), (i = 5 * Math.round(c.z / 5));
                    break;
                case 4:
                    (s = 5 * Math.round(c.x / 5)), (l = 5 * Math.round(c.y / 5)), (i = c.z + e);
                    break;
                case 5:
                    (s = 5 * Math.round(c.x / 5)), (l = 5 * Math.round(c.y / 5)), (i = c.z - e);
            }
            if ((l = Math.round(l)) > minWorldY) {
                var d = make_type,
                    h = new Block(s, l, i, !0, d);
                if (!intersect(h.x, h.y, h.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d)) {
                    chunks[identifyChunk(s, i)].push(h), placedBlocks.push(h);
                    var p = blockTypes.indexOf(d);
                    scene.remove(blocks[p].mesh), (blocks[p].mesh = new THREE.InstancedMesh(blockBox, blocks[p].materialArray, renderDistance * renderDistance * chunkSize * chunkSize * depth + placedBlocks.length)), (blocks[p].count = 0);
                    for (a = 0; a < chunks.length; a++)
                        for (var k = 0; k < chunks[a].length; k++) {
                            let e = new THREE.Matrix4().makeTranslation(chunks[a][k].x, chunks[a][k].y, chunks[a][k].z);
                            chunks[a][k].blockType == d && (blocks[p].mesh.setMatrixAt(blocks[p].count, e), blocks[p].count++);
                        }
                    scene.add(blocks[p].mesh);
                }
            }
        }
    }
    if (e.key == controlOptions.placeBlock && controls.isLocked) {
        const e = new THREE.Raycaster(),
            n = new THREE.Vector2();
        var u;
        (n.x = 0), (n.y = 0), e.setFromCamera(n, camera);
        for (r = !1, o = 1 / 0, a = 0; a < blocks.length; a++) {
            var y;
            null != (y = e.intersectObject(blocks[a].mesh))[0] && y[0].distance < 40 && y[0].distance < o && ((r = !0), (u = y), (o = y[0].distance));
        }
        if (null != u[0] && u[0].distance < 40) {
            console.log(u[0].point);
            (t = u[0].face.materialIndex), (c = u[0].point), (s = 0), (l = 0), (i = 0);
            const e = 2.5;
            switch (t) {
                case 0:
                    (s = c.x - e), (l = 5 * Math.round(c.y / 5)), (i = 5 * Math.round(c.z / 5));
                    break;
                case 1:
                    (s = c.x + e), (l = 5 * Math.round(c.y / 5)), (i = 5 * Math.round(c.z / 5));
                    break;
                case 2:
                    (s = 5 * Math.round(c.x / 5)), (l = c.y - e), (i = 5 * Math.round(c.z / 5));
                    break;
                case 3:
                    (s = 5 * Math.round(c.x / 5)), (l = c.y + e), (i = 5 * Math.round(c.z / 5));
                    break;
                case 4:
                    (s = 5 * Math.round(c.x / 5)), (l = 5 * Math.round(c.y / 5)), (i = c.z - e);
                    break;
                case 5:
                    (s = 5 * Math.round(c.x / 5)), (l = 5 * Math.round(c.y / 5)), (i = c.z + e);
            }
            var m = identifyChunk(s, i),
                f = chunks[m];
            l = Math.round(l);
            var b = null;
            for (a = 0; a < f.length; a++)
                if (f[a].x == s && f[a].y == l && f[a].z == i) {
                    if (f[a].placed) {
                        for (k = 0; k < placedBlocks.length; k++)
                            if (placedBlocks[k].x == s && placedBlocks[k].y == l && placedBlocks[k].z == i) {
                                placedBlocks.splice(k, 1);
                                break;
                            }
                    } else brokenBlocks.push(new Block(s, l, i, !1, f[a].blockType));
                    (b = f[a].blockType), chunks[m].splice(a, 1);
                    break;
                }
            p = blockTypes.indexOf(b);
            scene.remove(blocks[p].mesh), (blocks[p].mesh = new THREE.InstancedMesh(blockBox, blocks[p].materialArray, renderDistance * renderDistance * chunkSize * chunkSize * depth + placedBlocks.length)), (blocks[p].count = 0);
            for (a = 0; a < chunks.length; a++)
                for (k = 0; k < chunks[a].length; k++) {
                    let e = new THREE.Matrix4().makeTranslation(chunks[a][k].x, chunks[a][k].y, chunks[a][k].z);
                    chunks[a][k].blockType == b && (blocks[p].mesh.setMatrixAt(blocks[p].count, e), blocks[p].count++);
                }
            scene.add(blocks[p].mesh);
        }
    }
}),
    document.addEventListener("keyup", function (e) {
        for (var n = [], r = 0; r < keys.length; r++) keys[r] != e.key && n.push(keys[r]);
        (keys = n).includes("w") || (sprint = !1);
    });
var controls = new THREE.PointerLockControls(camera, document.body),
    brokenBlocks = [];
document.body.addEventListener("click", function (e) {
    if ((controls.lock(), 2 == e.button)) {
        if (controls.isLocked) {
            const e = new THREE.Raycaster(),
                m = new THREE.Vector2();
            (m.x = 0), (m.y = 0), e.setFromCamera(m, camera);
            for (var n = !1, r = 1 / 0, o = 0; o < blocks.length; o++) {
                null != (y = e.intersectObject(blocks[o].mesh))[0] && y[0].distance < 40 && y[0].distance < r && ((n = !0), (u = y), (r = y[0].distance));
            }
            if (null != u[0] && u[0].distance < 40) {
                console.log(u[0].point);
                var a = u[0].face.materialIndex,
                    t = u[0].point,
                    c = 0,
                    s = 0,
                    l = 0;
                const e = 2.5;
                switch (a) {
                    case 0:
                        (c = t.x - e), (s = 5 * Math.round(t.y / 5)), (l = 5 * Math.round(t.z / 5));
                        break;
                    case 1:
                        (c = t.x + e), (s = 5 * Math.round(t.y / 5)), (l = 5 * Math.round(t.z / 5));
                        break;
                    case 2:
                        (c = 5 * Math.round(t.x / 5)), (s = t.y - e), (l = 5 * Math.round(t.z / 5));
                        break;
                    case 3:
                        (c = 5 * Math.round(t.x / 5)), (s = t.y + e), (l = 5 * Math.round(t.z / 5));
                        break;
                    case 4:
                        (c = 5 * Math.round(t.x / 5)), (s = 5 * Math.round(t.y / 5)), (l = t.z - e);
                        break;
                    case 5:
                        (c = 5 * Math.round(t.x / 5)), (s = 5 * Math.round(t.y / 5)), (l = t.z + e);
                }
                var i = identifyChunk(c, l),
                    d = chunks[i];
                s = Math.round(s);
                var h = null;
                for (o = 0; o < d.length; o++)
                    if (d[o].x == c && d[o].y == s && d[o].z == l) {
                        if (d[o].placed) {
                            for (var p = 0; p < placedBlocks.length; p++)
                                if (placedBlocks[p].x == c && placedBlocks[p].y == s && placedBlocks[p].z == l) {
                                    placedBlocks.splice(p, 1);
                                    break;
                                }
                        } else brokenBlocks.push(new Block(c, s, l, !1, d[o].blockType));
                        (h = d[o].blockType), chunks[i].splice(o, 1);
                        break;
                    }
                var k = blockTypes.indexOf(h);
                scene.remove(blocks[k].mesh), (blocks[k].mesh = new THREE.InstancedMesh(blockBox, blocks[k].materialArray, renderDistance * renderDistance * chunkSize * chunkSize * depth + placedBlocks.length)), (blocks[k].count = 0);
                for (o = 0; o < chunks.length; o++)
                    for (p = 0; p < chunks[o].length; p++) {
                        let e = new THREE.Matrix4().makeTranslation(chunks[o][p].x, chunks[o][p].y, chunks[o][p].z);
                        chunks[o][p].blockType == h && (blocks[k].mesh.setMatrixAt(blocks[k].count, e), blocks[k].count++);
                    }
                scene.add(blocks[k].mesh);
            }
        }
    } else if (e.shiftKey || e.ctrlKey) {
        if (controls.isLocked) {
            const e = new THREE.Raycaster(),
                m = new THREE.Vector2();
            (m.x = 0), (m.y = 0), e.setFromCamera(m, camera);
            for (n = !1, r = 1 / 0, o = 0; o < blocks.length; o++) {
                null != (y = e.intersectObject(blocks[o].mesh))[0] && y[0].distance < 40 && y[0].distance < r && ((n = !0), (u = y), (r = y[0].distance));
            }
            if (null != u[0] && u[0].distance < 40) {
                console.log(u[0].point);
                (a = u[0].face.materialIndex), (t = u[0].point), (c = 0), (s = 0), (l = 0);
                const e = 2.5;
                switch (a) {
                    case 0:
                        (c = t.x - e), (s = 5 * Math.round(t.y / 5)), (l = 5 * Math.round(t.z / 5));
                        break;
                    case 1:
                        (c = t.x + e), (s = 5 * Math.round(t.y / 5)), (l = 5 * Math.round(t.z / 5));
                        break;
                    case 2:
                        (c = 5 * Math.round(t.x / 5)), (s = t.y - e), (l = 5 * Math.round(t.z / 5));
                        break;
                    case 3:
                        (c = 5 * Math.round(t.x / 5)), (s = t.y + e), (l = 5 * Math.round(t.z / 5));
                        break;
                    case 4:
                        (c = 5 * Math.round(t.x / 5)), (s = 5 * Math.round(t.y / 5)), (l = t.z - e);
                        break;
                    case 5:
                        (c = 5 * Math.round(t.x / 5)), (s = 5 * Math.round(t.y / 5)), (l = t.z + e);
                }
                (i = identifyChunk(c, l)), (d = chunks[i]);
                s = Math.round(s);
                for (h = null, o = 0; o < d.length; o++)
                    if (d[o].x == c && d[o].y == s && d[o].z == l) {
                        if (d[o].placed) {
                            for (p = 0; p < placedBlocks.length; p++)
                                if (placedBlocks[p].x == c && placedBlocks[p].y == s && placedBlocks[p].z == l) {
                                    placedBlocks.splice(p, 1);
                                    break;
                                }
                        } else brokenBlocks.push(new Block(c, s, l, !1, d[o].blockType));
                        (h = d[o].blockType), chunks[i].splice(o, 1);
                        break;
                    }
                k = blockTypes.indexOf(h);
                scene.remove(blocks[k].mesh), (blocks[k].mesh = new THREE.InstancedMesh(blockBox, blocks[k].materialArray, renderDistance * renderDistance * chunkSize * chunkSize * depth + placedBlocks.length)), (blocks[k].count = 0);
                for (o = 0; o < chunks.length; o++)
                    for (p = 0; p < chunks[o].length; p++) {
                        let e = new THREE.Matrix4().makeTranslation(chunks[o][p].x, chunks[o][p].y, chunks[o][p].z);
                        chunks[o][p].blockType == h && (blocks[k].mesh.setMatrixAt(blocks[k].count, e), blocks[k].count++);
                    }
                scene.add(blocks[k].mesh);
            }
        }
    } else {
        const e = new THREE.Raycaster(),
            i = new THREE.Vector2();
        var u;
        (i.x = 0), (i.y = 0), e.setFromCamera(i, camera);
        for (var n = !1, r = 1 / 0, o = 0; o < blocks.length; o++) {
            var y;
            null != (y = e.intersectObject(blocks[o].mesh))[0] && y[0].distance < 40 && y[0].distance < r && ((n = !0), (u = y), (r = y[0].distance));
        }
        if (n) {
            console.log(u[0]);
            var a = u[0].face.materialIndex,
                t = u[0].point,
                c = 0,
                s = 0,
                l = 0;
            const e = 2.5;
            switch (a) {
                case 0:
                    (c = t.x + e), (s = 5 * Math.round(t.y / 5)), (l = 5 * Math.round(t.z / 5));
                    break;
                case 1:
                    (c = t.x - e), (s = 5 * Math.round(t.y / 5)), (l = 5 * Math.round(t.z / 5));
                    break;
                case 2:
                    (c = 5 * Math.round(t.x / 5)), (s = t.y + e), (l = 5 * Math.round(t.z / 5));
                    break;
                case 3:
                    (c = 5 * Math.round(t.x / 5)), (s = t.y - e), (l = 5 * Math.round(t.z / 5));
                    break;
                case 4:
                    (c = 5 * Math.round(t.x / 5)), (s = 5 * Math.round(t.y / 5)), (l = t.z + e);
                    break;
                case 5:
                    (c = 5 * Math.round(t.x / 5)), (s = 5 * Math.round(t.y / 5)), (l = t.z - e);
            }
            if ((s = Math.round(s)) > minWorldY) {
                var m = make_type,
                    f = new Block(c, s, l, !0, m);
                if (!intersect(f.x, f.y, f.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d)) {
                    chunks[identifyChunk(c, l)].push(f), placedBlocks.push(f);
                    var k = blockTypes.indexOf(m);
                    scene.remove(blocks[k].mesh), (blocks[k].mesh = new THREE.InstancedMesh(blockBox, blocks[k].materialArray, renderDistance * renderDistance * chunkSize * chunkSize * depth + placedBlocks.length)), (blocks[k].count = 0);
                    for (var o = 0; o < chunks.length; o++)
                        for (var p = 0; p < chunks[o].length; p++) {
                            let e = new THREE.Matrix4().makeTranslation(chunks[o][p].x, chunks[o][p].y, chunks[o][p].z);
                            chunks[o][p].blockType == m && (blocks[k].mesh.setMatrixAt(blocks[k].count, e), blocks[k].count++);
                        }
                    scene.add(blocks[k].mesh);
                }
            }
        }
    }
}),
    controls.addEventListener("lock", function () {}),
    controls.addEventListener("unlock", function () {
        keys = [];
    });
var movingSpeed = 0.5,
    ySpeed = 0,
    acc = 0.065,
    player = {
        w: 0.6,
        h: 8,
        d: 0.5,
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z,
        forward: function (e) {
            controls.moveForward(e), this.updatePosition();
        },
        backward: function (e) {
            controls.moveForward(-1 * e), this.updatePosition();
        },
        right: function (e) {
            controls.moveRight(e), this.updatePosition();
        },
        left: function (e) {
            controls.moveRight(-1 * e), this.updatePosition();
        },
        updatePosition: function () {
            (this.x = camera.position.x), (this.y = camera.position.y - this.h / 2), (this.z = camera.position.z);
        },
    };
function intersect(e, n, r, o, a, t, c, s, l, i, d, h) {
    return e - o / 2 <= c + i / 2 && e + o / 2 >= c - i / 2 && n - a / 2 <= s + d / 2 && n + a / 2 >= s - d / 2 && r - t / 2 <= l + h / 2 && r + t / 2 >= l - h / 2;
}
var deceleration = 1.35,
    forback = 0,
    rightleft = 0,
    sprintSpeedInc = 1.6;
function update() {
    if ((player.updatePosition(), keys.includes(controlOptions.forward))) {
        player.forward(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 1 * movingSpeed);
        for (var e = 0; e < chunks.length; e++)
            for (var n = 0; n < chunks[e].length; n++) {
                intersect((y = chunks[e][n]).x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) &&
                    y.y - 2.5 < player.y + player.h / 2 &&
                    y.y + 2.5 > player.y - player.h / 2 &&
                    (player.backward(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 0), (rightleft = 0), (sprint = !0));
            }
    }
    if (keys.includes(controlOptions.up)) {
        player.forward(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 1 * movingSpeed);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                intersect((y = chunks[e][n]).x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) &&
                    y.y - 2.5 < player.y + player.h / 2 &&
                    y.y + 2.5 > player.y - player.h / 2 &&
                    (player.backward(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 0), (rightleft = 0), (sprint = !0));
            }
    }
    if (keys.includes(controlOptions.backward)) {
        player.backward(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = -1 * movingSpeed);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                intersect((y = chunks[e][n]).x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) &&
                    y.y - 2.5 < player.y + player.h / 2 &&
                    y.y + 2.5 > player.y - player.h / 2 &&
                    (player.forward(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 0), (rightleft = 0), (sprint = !1));
            }
    }
    if (keys.includes(controlOptions.down)) {
        player.backward(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = -1 * movingSpeed);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                intersect((y = chunks[e][n]).x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) &&
                    y.y - 2.5 < player.y + player.h / 2 &&
                    y.y + 2.5 > player.y - player.h / 2 &&
                    (player.forward(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 0), (rightleft = 0), (sprint = !1));
            }
    }
    if (keys.includes(controlOptions.right)) {
        player.right(movingSpeed * (sprint ? sprintSpeedInc : 1)), (rightleft = 1 * movingSpeed);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                intersect((y = chunks[e][n]).x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) &&
                    y.y - 2.5 < player.y + player.h / 2 &&
                    y.y + 2.5 > player.y - player.h / 2 &&
                    (player.left(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 0), (rightleft = 0), (sprint = !1));
            }
    }
    if (keys.includes(controlOptions.rarrow)) {
        player.right(movingSpeed * (sprint ? sprintSpeedInc : 1)), (rightleft = 1 * movingSpeed);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                intersect((y = chunks[e][n]).x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) &&
                    y.y - 2.5 < player.y + player.h / 2 &&
                    y.y + 2.5 > player.y - player.h / 2 &&
                    (player.left(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 0), (rightleft = 0), (sprint = !1));
            }
    }
    if (keys.includes(controlOptions.left)) {
        player.left(movingSpeed * (sprint ? sprintSpeedInc : 1)), (rightleft = -1 * movingSpeed);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                intersect((y = chunks[e][n]).x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) &&
                    y.y - 2.5 < player.y + player.h / 2 &&
                    y.y + 2.5 > player.y - player.h / 2 &&
                    (player.right(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 0), (rightleft = 0), (sprint = !1));
            }
    }
    if (keys.includes(controlOptions.larrow)) {
        player.left(movingSpeed * (sprint ? sprintSpeedInc : 1)), (rightleft = -1 * movingSpeed);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                intersect((y = chunks[e][n]).x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) &&
                    y.y - 2.5 < player.y + player.h / 2 &&
                    y.y + 2.5 > player.y - player.h / 2 &&
                    (player.right(movingSpeed * (sprint ? sprintSpeedInc : 1)), (forback = 0), (rightleft = 0), (sprint = !1));
            }
    }
    if (
        !(
            keys.includes(controlOptions.forward) ||
            keys.includes(controlOptions.backward) ||
            keys.includes(controlOptions.right) ||
            keys.includes(controlOptions.left) ||
            keys.includes(controlOptions.up) ||
            keys.includes(controlOptions.down) ||
            keys.includes(controlOptions.rarrow) ||
            keys.includes(controlOptions.larrow)
        )
    ) {
        (forback /= deceleration), (rightleft /= deceleration);
        for (e = 0; e < chunks.length; e++) {
            for (n = 0; n < chunks[e].length; n++) {
                if (intersect((y = chunks[e][n]).x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) && y.y - 2.5 < player.y + player.h / 2 && y.y + 2.5 > player.y - player.h / 2) {
                    var r = !0;
                    (forback /= -deceleration), (rightleft /= -deceleration), (sprint = !1);
                    break;
                }
            }
            if (r) break;
        }
        player.forward(forback * (sprint ? sprintSpeedInc : 1)), player.right(rightleft * (sprint ? sprintSpeedInc : 1));
    }
    (camera.position.y = camera.position.y - ySpeed), (ySpeed += acc);
    for (e = 0; e < chunks.length; e++)
        for (n = 0; n < chunks[e].length; n++) {
            intersect((y = chunks[e][n]).x, y.y + 10, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) &&
                camera.position.y <= chunks[e][n].y + 2.5 + player.h &&
                camera.position.y >= chunks[e][n].y &&
                ((camera.position.y = chunks[e][n].y + 2.5 + player.h), (ySpeed = 0), (canJump = !0)),
                intersect(y.x, y.y, y.z, 5, 5, 5, player.x, player.y, player.z, player.w, player.h, player.d) && camera.position.y >= chunks[e][n].y - 2.5 && camera.position.y <= chunks[e][n].y && (ySpeed = 0.5);
        }
    var o = chunkSize * renderDistance * 5;
    if (camera.position.z < lowestZBlock() + 0.4 * o) {
        var a = [];
        for (e = 0; e < chunks.length; e++) (e + 1) % renderDistance != 0 && a.push(chunks[e]);
        var t = lowestXBlock(),
            c = lowestZBlock();
        for (e = 0; e < renderDistance; e++) {
            for (var s = [], l = t + e * chunkSize * 5; l < t + e * chunkSize * 5 + 5 * chunkSize; l += 5)
                for (var i = c - 5 * chunkSize; i < c; i += 5) {
                    (xoff = (inc * l) / 5), (zoff = (inc * i) / 5);
                    for (var d = 5 * Math.round((noise.perlin2(xoff, zoff) * amplitude) / 5), h = 0; h < depth; h++)
                        if (!(d - 5 * h < minWorldY)) {
                            for (var p = !1, k = 0; k < brokenBlocks.length; k++)
                                if (brokenBlocks[k].x == l && brokenBlocks[k].y == d - 5 * h && brokenBlocks[k].z == i) {
                                    p = !0;
                                    break;
                                }
                            if (!p)
                                for (var u = 0; u < blocks.length; u++)
                                    if (blocks[u].range.includes(h)) {
                                        s.push(new Block(l, d - 5 * h, i, !1, blocks[u].name));
                                        break;
                                    }
                        }
                    for (var y = 0; y < placedBlocks.length; y++) placedBlocks[y].x == l && placedBlocks[y].z == i && s.push(new Block(placedBlocks[y].x, placedBlocks[y].y, placedBlocks[y].z, !0, placedBlocks[y].blockType));
                }
            a.splice(e * renderDistance, 0, s);
        }
        chunks = a;
        for (e = 0; e < blocks.length; e++)
            scene.remove(blocks[e].mesh), (blocks[e].mesh = new THREE.InstancedMesh(blockBox, blocks[e].materialArray, renderDistance * renderDistance * chunkSize * chunkSize * depth + placedBlocks.length)), (blocks[e].count = 0);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                let r = new THREE.Matrix4().makeTranslation(chunks[e][n].x, chunks[e][n].y, chunks[e][n].z);
                for (u = 0; u < blocks.length; u++)
                    if (blocks[u].name == chunks[e][n].blockType) {
                        blocks[u].mesh.setMatrixAt(blocks[u].count, r), blocks[u].count++;
                        break;
                    }
            }
        for (e = 0; e < blocks.length; e++) scene.add(blocks[e].mesh);
    }
    if (camera.position.z > highestZBlock() - 0.4 * o) {
        for (a = [], e = 0; e < chunks.length; e++) e % renderDistance != 0 && a.push(chunks[e]);
        t = lowestXBlock();
        var m = highestZBlock();
        for (e = 0; e < renderDistance; e++) {
            for (s = [], l = t + e * chunkSize * 5; l < t + e * chunkSize * 5 + 5 * chunkSize; l += 5)
                for (i = m + 5; i < m + 5 + 5 * chunkSize; i += 5) {
                    (xoff = (inc * l) / 5), (zoff = (inc * i) / 5);
                    for (d = 5 * Math.round((noise.perlin2(xoff, zoff) * amplitude) / 5), h = 0; h < depth; h++)
                        if (!(d - 5 * h < minWorldY)) {
                            for (p = !1, k = 0; k < brokenBlocks.length; k++)
                                if (brokenBlocks[k].x == l && brokenBlocks[k].y == d - 5 * h && brokenBlocks[k].z == i) {
                                    p = !0;
                                    break;
                                }
                            if (!p)
                                for (u = 0; u < blocks.length; u++)
                                    if (blocks[u].range.includes(h)) {
                                        s.push(new Block(l, d - 5 * h, i, !1, blocks[u].name));
                                        break;
                                    }
                        }
                    for (y = 0; y < placedBlocks.length; y++) placedBlocks[y].x == l && placedBlocks[y].z == i && s.push(new Block(placedBlocks[y].x, placedBlocks[y].y, placedBlocks[y].z, !0, placedBlocks[y].blockType));
                }
            a.splice((e + 1) * renderDistance - 1, 0, s);
        }
        chunks = a;
        for (e = 0; e < blocks.length; e++)
            scene.remove(blocks[e].mesh), (blocks[e].mesh = new THREE.InstancedMesh(blockBox, blocks[e].materialArray, renderDistance * renderDistance * chunkSize * chunkSize * depth + placedBlocks.length)), (blocks[e].count = 0);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                let r = new THREE.Matrix4().makeTranslation(chunks[e][n].x, chunks[e][n].y, chunks[e][n].z);
                for (u = 0; u < blocks.length; u++)
                    if (blocks[u].name == chunks[e][n].blockType) {
                        blocks[u].mesh.setMatrixAt(blocks[u].count, r), blocks[u].count++;
                        break;
                    }
            }
        for (e = 0; e < blocks.length; e++) scene.add(blocks[e].mesh);
    }
    if (camera.position.x > highestXBlock() - 0.4 * o) {
        for (a = [], e = renderDistance; e < chunks.length; e++) a.push(chunks[e]);
        var f = highestXBlock();
        for (c = lowestZBlock(), e = 0; e < renderDistance; e++) {
            for (s = [], i = c + e * chunkSize * 5; i < c + e * chunkSize * 5 + 5 * chunkSize; i += 5)
                for (l = f + 5; l < f + 5 + 5 * chunkSize; l += 5) {
                    (xoff = (inc * l) / 5), (zoff = (inc * i) / 5);
                    for (d = 5 * Math.round((noise.perlin2(xoff, zoff) * amplitude) / 5), h = 0; h < depth; h++)
                        if (!(d - 5 * h < minWorldY)) {
                            for (p = !1, k = 0; k < brokenBlocks.length; k++)
                                if (brokenBlocks[k].x == l && brokenBlocks[k].y == d - 5 * h && brokenBlocks[k].z == i) {
                                    p = !0;
                                    break;
                                }
                            if (!p)
                                for (u = 0; u < blocks.length; u++)
                                    if (blocks[u].range.includes(h)) {
                                        s.push(new Block(l, d - 5 * h, i, !1, blocks[u].name));
                                        break;
                                    }
                        }
                    for (y = 0; y < placedBlocks.length; y++) placedBlocks[y].x == l && placedBlocks[y].z == i && s.push(new Block(placedBlocks[y].x, placedBlocks[y].y, placedBlocks[y].z, !0, placedBlocks[y].blockType));
                }
            a.splice(chunks.length - (renderDistance - e), 0, s);
        }
        chunks = a;
        for (e = 0; e < blocks.length; e++)
            scene.remove(blocks[e].mesh), (blocks[e].mesh = new THREE.InstancedMesh(blockBox, blocks[e].materialArray, renderDistance * renderDistance * chunkSize * chunkSize * depth + placedBlocks.length)), (blocks[e].count = 0);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                let r = new THREE.Matrix4().makeTranslation(chunks[e][n].x, chunks[e][n].y, chunks[e][n].z);
                for (u = 0; u < blocks.length; u++)
                    if (blocks[u].name == chunks[e][n].blockType) {
                        blocks[u].mesh.setMatrixAt(blocks[u].count, r), blocks[u].count++;
                        break;
                    }
            }
        for (e = 0; e < blocks.length; e++) scene.add(blocks[e].mesh);
    }
    if (camera.position.x < lowestXBlock() + 0.4 * o) {
        for (a = [], e = 0; e < chunks.length - renderDistance; e++) a.push(chunks[e]);
        for (t = lowestXBlock(), c = lowestZBlock(), e = 0; e < renderDistance; e++) {
            for (s = [], i = c + e * chunkSize * 5; i < c + e * chunkSize * 5 + 5 * chunkSize; i += 5)
                for (l = t - 5 * chunkSize; l < t; l += 5) {
                    (xoff = (inc * l) / 5), (zoff = (inc * i) / 5);
                    for (d = 5 * Math.round((noise.perlin2(xoff, zoff) * amplitude) / 5), h = 0; h < depth; h++)
                        if (!(d - 5 * h < minWorldY)) {
                            for (p = !1, k = 0; k < brokenBlocks.length; k++)
                                if (brokenBlocks[k].x == l && brokenBlocks[k].y == d - 5 * h && brokenBlocks[k].z == i) {
                                    p = !0;
                                    break;
                                }
                            if (!p)
                                for (u = 0; u < blocks.length; u++)
                                    if (blocks[u].range.includes(h)) {
                                        s.push(new Block(l, d - 5 * h, i, !1, blocks[u].name));
                                        break;
                                    }
                        }
                    for (y = 0; y < placedBlocks.length; y++) placedBlocks[y].x == l && placedBlocks[y].z == i && s.push(new Block(placedBlocks[y].x, placedBlocks[y].y, placedBlocks[y].z, !0, placedBlocks[y].blockType));
                }
            a.splice(e, 0, s);
        }
        chunks = a;
        for (e = 0; e < blocks.length; e++)
            scene.remove(blocks[e].mesh), (blocks[e].mesh = new THREE.InstancedMesh(blockBox, blocks[e].materialArray, renderDistance * renderDistance * chunkSize * chunkSize * depth + placedBlocks.length)), (blocks[e].count = 0);
        for (e = 0; e < chunks.length; e++)
            for (n = 0; n < chunks[e].length; n++) {
                let r = new THREE.Matrix4().makeTranslation(chunks[e][n].x, chunks[e][n].y, chunks[e][n].z);
                for (u = 0; u < blocks.length; u++)
                    if (blocks[u].name == chunks[e][n].blockType) {
                        blocks[u].mesh.setMatrixAt(blocks[u].count, r), blocks[u].count++;
                        break;
                    }
            }
        for (e = 0; e < blocks.length; e++) scene.add(blocks[e].mesh);
    }
}
function lowestXBlock() {
    for (var e = [], n = 0; n < chunks.length; n++) for (var r = 0; r < chunks[n].length; r++) e.push(chunks[n][r].x);
    return Math.min.apply(null, e);
}
function highestXBlock() {
    for (var e = [], n = 0; n < chunks.length; n++) for (var r = 0; r < chunks[n].length; r++) e.push(chunks[n][r].x);
    return Math.max.apply(null, e);
}
function lowestZBlock() {
    for (var e = [], n = 0; n < chunks.length; n++) for (var r = 0; r < chunks[n].length; r++) e.push(chunks[n][r].z);
    return Math.min.apply(null, e);
}
function highestZBlock() {
    for (var e = [], n = 0; n < chunks.length; n++) for (var r = 0; r < chunks[n].length; r++) e.push(chunks[n][r].z);
    return Math.max.apply(null, e);
}
window.addEventListener("resize", function () {
    renderer.setSize(window.innerWidth, window.innerHeight),
        (camera.aspect = window.innerWidth / window.innerHeight),
        camera.updateProjectionMatrix(),
        (cursor.style.left = (0.5 * window.innerWidth - 0.5 * cursor.width).toString() + "px"),
        (cursor.style.top = (0.5 * window.innerHeight - 0.5 * cursor.height).toString() + "px");
});
const raycaster = new THREE.Raycaster(),
    pointer = new THREE.Vector2();
var plane;
function render() {
    var e;
    raycaster.setFromCamera(pointer, camera);
    for (var n = !1, r = 1 / 0, o = 0; o < blocks.length; o++) {
        var a = raycaster.intersectObject(blocks[o].mesh);
        null != a[0] && a[0].distance < 40 && a[0].distance < r && ((n = !0), (e = a), (r = a[0].distance));
    }
    if (n)
        if (scene.children.includes(plane)) {
            plane.visible = !0;
            var t = e[0].face.materialIndex,
                c = e[0].point,
                s = 0,
                l = 0,
                i = 0;
            const n = 0.1;
            switch (t) {
                case 0:
                    (plane.rotation.x = 0), (plane.rotation.y = Math.PI / 2), (plane.rotation.z = 0), (s = c.x + n), (l = 5 * Math.round(c.y / 5)), (i = 5 * Math.round(c.z / 5));
                    break;
                case 1:
                    (plane.rotation.x = 0), (plane.rotation.y = Math.PI / 2), (plane.rotation.z = 0), (s = c.x - n), (l = 5 * Math.round(c.y / 5)), (i = 5 * Math.round(c.z / 5));
                    break;
                case 2:
                    (plane.rotation.x = Math.PI / 2), (plane.rotation.y = 0), (plane.rotation.z = 0), (s = 5 * Math.round(c.x / 5)), (l = c.y + n), (i = 5 * Math.round(c.z / 5));
                    break;
                case 3:
                    (plane.rotation.x = Math.PI / 2), (plane.rotation.y = 0), (plane.rotation.z = 0), (s = 5 * Math.round(c.x / 5)), (l = c.y - n), (i = 5 * Math.round(c.z / 5));
                    break;
                case 4:
                    (plane.rotation.x = 0), (plane.rotation.y = 0), (plane.rotation.z = 0), (s = 5 * Math.round(c.x / 5)), (l = 5 * Math.round(c.y / 5)), (i = c.z + n);
                    break;
                case 5:
                    (plane.rotation.x = 0), (plane.rotation.y = 0), (plane.rotation.z = 0), (s = 5 * Math.round(c.x / 5)), (l = 5 * Math.round(c.y / 5)), (i = c.z - n);
            }
            (plane.position.x = s), (plane.position.y = l), (plane.position.z = i);
        } else {
            var d = new THREE.PlaneGeometry(5, 5),
                h = new THREE.MeshBasicMaterial({ color: 16777215, side: THREE.DoubleSide });
            (h.transparent = !0), (h.opacity = 0.5), (plane = new THREE.Mesh(d, h)), scene.add(plane);
        }
    else plane && (plane.visible = !1);
    renderer.render(scene, camera);
}
function GameLoop() {
    requestAnimationFrame(GameLoop), update(), render();
}
(pointer.x = 0), (pointer.y = 0), GameLoop();