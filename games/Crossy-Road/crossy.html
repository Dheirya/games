<!DOCTYPE html>
<html>
    <head>
        <title>Crossy Road Game</title>
        <style>
            @import url("https://fonts.googleapis.com/css?family=Press+Start+2P");
            body {
                margin: 0;
                font-family: "Press Start 2P", cursive;
                font-size: 2em;
                color: white;
            }
            button {
                outline: none;
                cursor: pointer;
                border: none;
                box-shadow: 3px 5px 0px 0px rgba(0, 0, 0, 0.75);
            }
            #counter {
                position: absolute;
                top: 20px;
                right: 20px;
            }
            #end {
                position: absolute;
                min-width: 100%;
                min-height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                visibility: hidden;
            }
            #end button {
                background-color: red;
                padding: 20px 50px 20px 50px;
                font-family: inherit;
                font-size: inherit;
            }
            #controlls {
                position: absolute;
                min-width: 100%;
                min-height: 100%;
                display: flex;
                align-items: flex-end;
                justify-content: center;
            }
            #controlls div {
                display: grid;
                grid-template-columns: 50px 50px 50px;
                grid-template-rows: auto auto;
                grid-column-gap: 10px;
                grid-row-gap: 10px;
                margin-bottom: 20px;
            }
            #controlls button {
                width: 100%;
                background-color: white;
                border: 1px solid lightgray;
            }
            #controlls button:first-of-type {
                grid-column: 1/-1;
            }
        </style>
    </head>
    <body oncontextmenu="return false" style="background-image: url('https://res.cloudinary.com/dpoer5oaq/image/upload/v1630345961/wp3255727_skdva5.jpg');">
        <div id="counter">0</div>
        <div id="controlls">
            <div>
                <button id="forward">
                    <svg width="30" height="30" viewBox="0 0 10 10">
                        <g transform="rotate(0, 5,5)">
                            <path d="M5,4 L7,6 L3,6 L5,4" />
                        </g>
                    </svg>
                </button>
                <button id="left">
                    <svg width="30" height="30" viewBox="0 0 10 10">
                        <g transform="rotate(-90, 5,5)">
                            <path d="M5,4 L7,6 L3,6 L5,4" />
                        </g>
                    </svg>
                </button>
                <button id="backward">
                    <svg width="30" height="30" viewBox="0 0 10 10">
                        <g transform="rotate(180, 5,5)">
                            <path d="M5,4 L7,6 L3,6 L5,4" />
                        </g>
                    </svg>
                </button>
                <button id="right">
                    <svg width="30" height="30" viewBox="0 0 10 10">
                        <g transform="rotate(90, 5,5)">
                            <path d="M5,4 L7,6 L3,6 L5,4" />
                        </g>
                    </svg>
                </button>
            </div>
        </div>
        <div id="end">
            <button id="retry">Retry</button>
        </div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"></script>
        <script>
            const counterDOM = document.getElementById("counter"),
                endDOM = document.getElementById("end"),
                scene = new THREE.Scene(),
                distance = 500,
                camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.1, 1e4);
            (camera.rotation.x = (50 * Math.PI) / 180), (camera.rotation.y = (20 * Math.PI) / 180), (camera.rotation.z = (10 * Math.PI) / 180);
            const initialCameraPositionY = 500 * -Math.tan(camera.rotation.x),
                initialCameraPositionX = Math.tan(camera.rotation.y) * Math.sqrt(25e4 + initialCameraPositionY ** 2);
            (camera.position.y = initialCameraPositionY), (camera.position.x = initialCameraPositionX), (camera.position.z = 500);
            const zoom = 2,
                chickenSize = 15,
                positionWidth = 42,
                columns = 17,
                boardWidth = positionWidth * columns,
                stepTime = 200;
            let lanes, currentLane, currentColumn, previousTimestamp, startMoving, moves, stepStartTimestamp;
            const carFrontTexture = new Texture(40, 80, [{ x: 0, y: 10, w: 30, h: 60 }]),
                carBackTexture = new Texture(40, 80, [{ x: 10, y: 10, w: 30, h: 60 }]),
                carRightSideTexture = new Texture(110, 40, [
                    { x: 10, y: 0, w: 50, h: 30 },
                    { x: 70, y: 0, w: 30, h: 30 },
                ]),
                carLeftSideTexture = new Texture(110, 40, [
                    { x: 10, y: 10, w: 50, h: 30 },
                    { x: 70, y: 10, w: 30, h: 30 },
                ]),
                truckFrontTexture = new Texture(30, 30, [{ x: 15, y: 0, w: 10, h: 30 }]),
                truckRightSideTexture = new Texture(25, 30, [{ x: 0, y: 15, w: 10, h: 10 }]),
                truckLeftSideTexture = new Texture(25, 30, [{ x: 0, y: 5, w: 10, h: 10 }]),
                generateLanes = () =>
                    [-9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
                        .map((e) => {
                            const o = new Lane(e);
                            return (o.mesh.position.y = e * positionWidth * zoom), scene.add(o.mesh), o;
                        })
                        .filter((e) => e.index >= 0),
                addLane = () => {
                    const e = lanes.length,
                        o = new Lane(e);
                    (o.mesh.position.y = e * positionWidth * zoom), scene.add(o.mesh), lanes.push(o);
                },
                chicken = new Chicken();
            scene.add(chicken), (hemiLight = new THREE.HemisphereLight(16777215, 16777215, 0.6)), scene.add(hemiLight);
            const initialDirLightPositionX = -100,
                initialDirLightPositionY = -100;
            (dirLight = new THREE.DirectionalLight(16777215, 0.6)),
                dirLight.position.set(initialDirLightPositionX, initialDirLightPositionY, 200),
                (dirLight.castShadow = !0),
                (dirLight.target = chicken),
                scene.add(dirLight),
                (dirLight.shadow.mapSize.width = 2048),
                (dirLight.shadow.mapSize.height = 2048);
            var d = 500;
            (dirLight.shadow.camera.left = -d),
                (dirLight.shadow.camera.right = d),
                (dirLight.shadow.camera.top = d),
                (dirLight.shadow.camera.bottom = -d),
                (backLight = new THREE.DirectionalLight(0, 0.4)),
                backLight.position.set(200, 200, 50),
                (backLight.castShadow = !0),
                scene.add(backLight);
            const laneTypes = ["car", "truck", "forest"],
                laneSpeeds = [2, 2.5, 3],
                vechicleColors = [10822947, 12432952, 7909707],
                threeHeights = [20, 45, 60],
                initaliseValues = () => {
                    (lanes = generateLanes()),
                        (currentLane = 0),
                        (currentColumn = Math.floor(columns / 2)),
                        (previousTimestamp = null),
                        (startMoving = !1),
                        (moves = []),
                        (chicken.position.x = 0),
                        (chicken.position.y = 0),
                        (camera.position.y = initialCameraPositionY),
                        (camera.position.x = initialCameraPositionX),
                        (dirLight.position.x = initialDirLightPositionX),
                        (dirLight.position.y = initialDirLightPositionY);
                };
            initaliseValues();
            const renderer = new THREE.WebGLRenderer({ alpha: !0, antialias: !0 });
            function Texture(e, o, i) {
                const t = document.createElement("canvas");
                (t.width = e), (t.height = o);
                const n = t.getContext("2d");
                return (
                    (n.fillStyle = "#ffffff"),
                    n.fillRect(0, 0, e, o),
                    (n.fillStyle = "rgba(0,0,0,0.6)"),
                    i.forEach((e) => {
                        n.fillRect(e.x, e.y, e.w, e.h);
                    }),
                    new THREE.CanvasTexture(t)
                );
            }
            function Wheel() {
                const e = new THREE.Mesh(new THREE.BoxBufferGeometry(12 * zoom, 33 * zoom, 12 * zoom), new THREE.MeshLambertMaterial({ color: 3355443, flatShading: !0 }));
                return (e.position.z = 6 * zoom), e;
            }
            function Car() {
                const e = new THREE.Group(),
                    o = vechicleColors[Math.floor(Math.random() * vechicleColors.length)],
                    i = new THREE.Mesh(new THREE.BoxBufferGeometry(60 * zoom, 30 * zoom, 15 * zoom), new THREE.MeshPhongMaterial({ color: o, flatShading: !0 }));
                (i.position.z = 12 * zoom), (i.castShadow = !0), (i.receiveShadow = !0), e.add(i);
                const t = new THREE.Mesh(new THREE.BoxBufferGeometry(33 * zoom, 24 * zoom, 12 * zoom), [
                    new THREE.MeshPhongMaterial({ color: 13421772, flatShading: !0, map: carBackTexture }),
                    new THREE.MeshPhongMaterial({ color: 13421772, flatShading: !0, map: carFrontTexture }),
                    new THREE.MeshPhongMaterial({ color: 13421772, flatShading: !0, map: carRightSideTexture }),
                    new THREE.MeshPhongMaterial({ color: 13421772, flatShading: !0, map: carLeftSideTexture }),
                    new THREE.MeshPhongMaterial({ color: 13421772, flatShading: !0 }),
                    new THREE.MeshPhongMaterial({ color: 13421772, flatShading: !0 }),
                ]);
                (t.position.x = 6 * zoom), (t.position.z = 25.5 * zoom), (t.castShadow = !0), (t.receiveShadow = !0), e.add(t);
                const n = new Wheel();
                (n.position.x = -18 * zoom), e.add(n);
                const a = new Wheel();
                return (a.position.x = 18 * zoom), e.add(a), (e.castShadow = !0), (e.receiveShadow = !1), e;
            }
            function Truck() {
                const e = new THREE.Group(),
                    o = vechicleColors[Math.floor(Math.random() * vechicleColors.length)],
                    i = new THREE.Mesh(new THREE.BoxBufferGeometry(100 * zoom, 25 * zoom, 5 * zoom), new THREE.MeshLambertMaterial({ color: 11847420, flatShading: !0 }));
                (i.position.z = 10 * zoom), e.add(i);
                const t = new THREE.Mesh(new THREE.BoxBufferGeometry(75 * zoom, 35 * zoom, 40 * zoom), new THREE.MeshPhongMaterial({ color: 11847420, flatShading: !0 }));
                (t.position.x = 15 * zoom), (t.position.z = 30 * zoom), (t.castShadow = !0), (t.receiveShadow = !0), e.add(t);
                const n = new THREE.Mesh(new THREE.BoxBufferGeometry(25 * zoom, 30 * zoom, 30 * zoom), [
                    new THREE.MeshPhongMaterial({ color: o, flatShading: !0 }),
                    new THREE.MeshPhongMaterial({ color: o, flatShading: !0, map: truckFrontTexture }),
                    new THREE.MeshPhongMaterial({ color: o, flatShading: !0, map: truckRightSideTexture }),
                    new THREE.MeshPhongMaterial({ color: o, flatShading: !0, map: truckLeftSideTexture }),
                    new THREE.MeshPhongMaterial({ color: o, flatShading: !0 }),
                    new THREE.MeshPhongMaterial({ color: o, flatShading: !0 }),
                ]);
                (n.position.x = -40 * zoom), (n.position.z = 20 * zoom), (n.castShadow = !0), (n.receiveShadow = !0), e.add(n);
                const a = new Wheel();
                (a.position.x = -38 * zoom), e.add(a);
                const r = new Wheel();
                (r.position.x = -10 * zoom), e.add(r);
                const s = new Wheel();
                return (s.position.x = 30 * zoom), e.add(s), e;
            }
            function Three() {
                const e = new THREE.Group(),
                    o = new THREE.Mesh(new THREE.BoxBufferGeometry(15 * zoom, 15 * zoom, 20 * zoom), new THREE.MeshPhongMaterial({ color: 5056806, flatShading: !0 }));
                (o.position.z = 10 * zoom), (o.castShadow = !0), (o.receiveShadow = !0), e.add(o), (height = threeHeights[Math.floor(Math.random() * threeHeights.length)]);
                const i = new THREE.Mesh(new THREE.BoxBufferGeometry(30 * zoom, 30 * zoom, height * zoom), new THREE.MeshLambertMaterial({ color: 8036893, flatShading: !0 }));
                return (i.position.z = (height / 2 + 20) * zoom), (i.castShadow = !0), (i.receiveShadow = !1), e.add(i), e;
            }
            function Chicken() {
                const e = new THREE.Group(),
                    o = new THREE.Mesh(new THREE.BoxBufferGeometry(chickenSize * zoom, chickenSize * zoom, 20 * zoom), new THREE.MeshPhongMaterial({ color: 16777215, flatShading: !0 }));
                (o.position.z = 10 * zoom), (o.castShadow = !0), (o.receiveShadow = !0), e.add(o);
                const i = new THREE.Mesh(new THREE.BoxBufferGeometry(2 * zoom, 4 * zoom, 2 * zoom), new THREE.MeshLambertMaterial({ color: 15753626, flatShading: !0 }));
                return (i.position.z = 21 * zoom), (i.castShadow = !0), (i.receiveShadow = !1), e.add(i), e;
            }
            function Road() {
                const e = new THREE.Group(),
                    o = (e) => new THREE.Mesh(new THREE.PlaneBufferGeometry(boardWidth * zoom, positionWidth * zoom), new THREE.MeshPhongMaterial({ color: e })),
                    i = o(4541017);
                (i.receiveShadow = !0), e.add(i);
                const t = o(3751241);
                (t.position.x = -boardWidth * zoom), e.add(t);
                const n = o(3751241);
                return (n.position.x = boardWidth * zoom), e.add(n), e;
            }
            function Grass() {
                const e = new THREE.Group(),
                    o = (e) => new THREE.Mesh(new THREE.BoxBufferGeometry(boardWidth * zoom, positionWidth * zoom, 3 * zoom), new THREE.MeshPhongMaterial({ color: e })),
                    i = o(12252245);
                (i.receiveShadow = !0), e.add(i);
                const t = o(10078278);
                (t.position.x = -boardWidth * zoom), e.add(t);
                const n = o(10078278);
                return (n.position.x = boardWidth * zoom), e.add(n), (e.position.z = 1.5 * zoom), e;
            }
            function Lane(e) {
                switch (((this.index = e), (this.type = e <= 0 ? "field" : laneTypes[Math.floor(Math.random() * laneTypes.length)]), this.type)) {
                    case "field":
                        (this.type = "field"), (this.mesh = new Grass());
                        break;
                    case "forest":
                        (this.mesh = new Grass()),
                            (this.occupiedPositions = new Set()),
                            (this.threes = [1, 2, 3, 4].map(() => {
                                const e = new Three();
                                let o;
                                do {
                                    o = Math.floor(Math.random() * columns);
                                } while (this.occupiedPositions.has(o));
                                return this.occupiedPositions.add(o), (e.position.x = (o * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2), this.mesh.add(e), e;
                            }));
                        break;
                    case "car": {
                        (this.mesh = new Road()), (this.direction = Math.random() >= 0.5);
                        const e = new Set();
                        (this.vechicles = [1, 2, 3].map(() => {
                            const o = new Car();
                            let i;
                            do {
                                i = Math.floor((Math.random() * columns) / 2);
                            } while (e.has(i));
                            return e.add(i), (o.position.x = (i * positionWidth * 2 + positionWidth / 2) * zoom - (boardWidth * zoom) / 2), this.direction || (o.rotation.z = Math.PI), this.mesh.add(o), o;
                        })),
                            (this.speed = laneSpeeds[Math.floor(Math.random() * laneSpeeds.length)]);
                        break;
                    }
                    case "truck": {
                        (this.mesh = new Road()), (this.direction = Math.random() >= 0.5);
                        const e = new Set();
                        (this.vechicles = [1, 2].map(() => {
                            const o = new Truck();
                            let i;
                            do {
                                i = Math.floor((Math.random() * columns) / 3);
                            } while (e.has(i));
                            return e.add(i), (o.position.x = (i * positionWidth * 3 + positionWidth / 2) * zoom - (boardWidth * zoom) / 2), this.direction || (o.rotation.z = Math.PI), this.mesh.add(o), o;
                        })),
                            (this.speed = laneSpeeds[Math.floor(Math.random() * laneSpeeds.length)]);
                        break;
                    }
                }
            }
            function move(e) {
                const o = moves.reduce(
                    (e, o) =>
                        "forward" === o
                            ? { lane: e.lane + 1, column: e.column }
                            : "backward" === o
                            ? { lane: e.lane - 1, column: e.column }
                            : "left" === o
                            ? { lane: e.lane, column: e.column - 1 }
                            : "right" === o
                            ? { lane: e.lane, column: e.column + 1 }
                            : void 0,
                    { lane: currentLane, column: currentColumn }
                );
                if ("forward" === e) {
                    if ("forest" === lanes[o.lane + 1].type && lanes[o.lane + 1].occupiedPositions.has(o.column)) return;
                    stepStartTimestamp || (startMoving = !0), addLane();
                } else if ("backward" === e) {
                    if (0 === o.lane) return;
                    if ("forest" === lanes[o.lane - 1].type && lanes[o.lane - 1].occupiedPositions.has(o.column)) return;
                    stepStartTimestamp || (startMoving = !0);
                } else if ("left" === e) {
                    if (0 === o.column) return;
                    if ("forest" === lanes[o.lane].type && lanes[o.lane].occupiedPositions.has(o.column - 1)) return;
                    stepStartTimestamp || (startMoving = !0);
                } else if ("right" === e) {
                    if (o.column === columns - 1) return;
                    if ("forest" === lanes[o.lane].type && lanes[o.lane].occupiedPositions.has(o.column + 1)) return;
                    stepStartTimestamp || (startMoving = !0);
                }
                moves.push(e);
            }
            function animate(e) {
                requestAnimationFrame(animate), previousTimestamp || (previousTimestamp = e);
                const o = e - previousTimestamp;
                if (
                    ((previousTimestamp = e),
                    lanes.forEach((e) => {
                        if ("car" === e.type || "truck" === e.type) {
                            const i = (-boardWidth * zoom) / 2 - 2 * positionWidth * zoom,
                                t = (boardWidth * zoom) / 2 + 2 * positionWidth * zoom;
                            e.vechicles.forEach((n) => {
                                e.direction ? (n.position.x = n.position.x < i ? t : (n.position.x -= (e.speed / 16) * o)) : (n.position.x = n.position.x > t ? i : (n.position.x += (e.speed / 16) * o));
                            });
                        }
                    }),
                    startMoving && ((stepStartTimestamp = e), (startMoving = !1)),
                    stepStartTimestamp)
                ) {
                    const o = e - stepStartTimestamp,
                        i = Math.min(o / stepTime, 1) * positionWidth * zoom,
                        t = 8 * Math.sin(Math.min(o / stepTime, 1) * Math.PI) * zoom;
                    switch (moves[0]) {
                        case "forward": {
                            const e = currentLane * positionWidth * zoom + i;
                            (camera.position.y = initialCameraPositionY + e), (dirLight.position.y = initialDirLightPositionY + e), (chicken.position.y = e), (chicken.position.z = t);
                            break;
                        }
                        case "backward":
                            (positionY = currentLane * positionWidth * zoom - i),
                                (camera.position.y = initialCameraPositionY + positionY),
                                (dirLight.position.y = initialDirLightPositionY + positionY),
                                (chicken.position.y = positionY),
                                (chicken.position.z = t);
                            break;
                        case "left": {
                            const e = (currentColumn * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2 - i;
                            (camera.position.x = initialCameraPositionX + e), (dirLight.position.x = initialDirLightPositionX + e), (chicken.position.x = e), (chicken.position.z = t);
                            break;
                        }
                        case "right": {
                            const e = (currentColumn * positionWidth + positionWidth / 2) * zoom - (boardWidth * zoom) / 2 + i;
                            (camera.position.x = initialCameraPositionX + e), (dirLight.position.x = initialDirLightPositionX + e), (chicken.position.x = e), (chicken.position.z = t);
                            break;
                        }
                    }
                    if (o > stepTime) {
                        switch (moves[0]) {
                            case "forward":
                                currentLane++, (counterDOM.innerHTML = currentLane);
                                break;
                            case "backward":
                                currentLane--, (counterDOM.innerHTML = currentLane);
                                break;
                            case "left":
                                currentColumn--;
                                break;
                            case "right":
                                currentColumn++;
                        }
                        moves.shift(), (stepStartTimestamp = 0 === moves.length ? null : e);
                    }
                }
                if ("car" === lanes[currentLane].type || "truck" === lanes[currentLane].type) {
                    const e = chicken.position.x - (chickenSize * zoom) / 2,
                        o = chicken.position.x + (chickenSize * zoom) / 2,
                        i = { car: 60, truck: 105 }[lanes[currentLane].type];
                    lanes[currentLane].vechicles.forEach((t) => {
                        const n = t.position.x - (i * zoom) / 2,
                            a = t.position.x + (i * zoom) / 2;
                        o > n && e < a && ((endDOM.style.visibility = "visible"), (document.querySelector("canvas").style.visibility = "hidden"), (document.querySelector("#controlls").style.visibility = "hidden"));
                    });
                }
                renderer.render(scene, camera);
            }
            (renderer.shadowMap.enabled = !0),
                (renderer.shadowMap.type = THREE.PCFSoftShadowMap),
                renderer.setSize(window.innerWidth, window.innerHeight),
                document.body.appendChild(renderer.domElement),
                document.querySelector("#retry").addEventListener("click", () => {
                    location.reload();
                }),
                document.getElementById("forward").addEventListener("click", () => move("forward")),
                document.getElementById("backward").addEventListener("click", () => move("backward")),
                document.getElementById("left").addEventListener("click", () => move("left")),
                document.getElementById("right").addEventListener("click", () => move("right")),
                window.addEventListener("keydown", (e) => {
                    "38" == e.keyCode ? move("forward") : "40" == e.keyCode ? move("backward") : "37" == e.keyCode ? move("left") : "39" == e.keyCode && move("right");
                }),
                requestAnimationFrame(animate);
        </script>
    </body>
</html>